basically fact(number) -> number;
func fact(0) return 1;
func fact(1) return 1;
func fact(n) return n * fact(n - 1);

func main() print(fact(4));

---

local function fact(n)
    if (n == 0) then
        return 1
    end
    if (n == 1) then
        return 1
    end
    return n * fact(n - 1)
end

---

TokFile
    TokFunction "fact"
        TokArgs
            TokNum 0.0
        TokReturn
            TokNum 1.0
    TokFunction "fact"
        TokArgs
            TokNum 1.0
        TokReturn
            TokNum 1.0
    TokFunction "fact"
        TokArgs
            TokDef "n"
        TokReturn                       4
            TokOpe SoMul                3
                TokDef "n"
                TokCall "fact"          1
                    TokOpe SoMinus      2
                        TokDef "n"
                        TokNum 1.0
    TokFunction "main"
        TokArgs
        TokCall "print"
            TokCall "fact"
                TokNum 5.0

---

-- BYTECODE -- a.lua:1-9
0001    ISNEN    0   0      ; 0
0002    JMP      1 => 0005
0003    KSHORT   1   1
0004    RET1     1   2
0005 => ISNEN    0   1      ; 1
0006    JMP      1 => 0009
0007    KSHORT   1   1
0008    RET1     1   2
0009 => UGET     1   0      ; fact
0010    SUBVN    3   0   1  ; 1
0011    CALL     1   2   2
0012    MULVV    1   0   1
0013    RET1     1   2

-- BYTECODE -- a.lua:0-11
0001    FNEW     0   0      ; a.lua:1
0002    GGET     1   1      ; "print"
0003    MOV      3   0
0004    KSHORT   5   4
0005    CALL     3   0   2
0006    CALLM    1   1   0
0007    UCLO     0 => 0008
0008 => RET0     0   1
---

-- BYTECODE -- file.factorial.lua:1-9               |   [0] = n
0001    ISNEN    0   0      ; 0                     |   if ([0] == 0)
0002    JMP      1 => 0005                          |       skip(3);
0003    KSHORT   1   1                              |   [1] = 1;
0004    RET1     1   2                              |   return [1];
0005 => ISNEN    0   1      ; 1                     |   if ([0] == 1)
0006    JMP      1 => 0009                          |       skip(3);
0007    KSHORT   1   1                              |   [1] = 1;
0008    RET1     1   2                              |   return [1];
0009 => UGET     1   0      ; factorial             |   [1] = getUpval(0); // sum
0010    SUBVN    2   0   1  ; 1                     |   [2] = [0] - 1; // n - 1
0011    CALL     1   2   2                          |   [1] = [1]([2]); // sum(n - 1)
0012    MULVV    1   0   1                          |   [1] = [0] * [1];
0013    RET1     1   2                              |   return [1];

-- BYTECODE -- file.factorial.lua:0-9
0001    FNEW     0   0      ; file.factorial.lua:1
0002    UCLO     0 => 0003
0003 => RET0     0   1

---

Raw bytes

1   ISNEN   = 09 00 00 00
2   JMP     = 58 01 02 80   (=> 2 + 02 + 1 = 5)
3   KSHORT  = 29 01 01 00
4   RET1    = 4c 01 02 00
5   ISNEN   = 09 00 01 00

---

// DEPRECATED !!!!!!

Instructions:

000       FSET [00][00  12] ; F[0] = PC - 0x12 (18) -> PC
001     CMPSHR  00 [00  00] ; R[0] compare 0
002         JG [00  00  02] ; R[0] > 0 ? PC += 2 (-> 003)
003       TRWS [00  00  00] ; throw "invalid type"
004       CMPS  00 [00  00] ; R[0] compare 0
005        JNE [00  00  03] ; R[0] != 0 ? PC += 3 (-> 007)
006      LDSHR  01 [00  01] ; R[1] = 1
007        RET [01][01] 00  ; return R[1]
008       CMPS  00 [00  01] ; R[0] compare 1
009        JNE [00  00  00] ; R[0] != 1 ? PC += 3 (-> 011)
010      LDSHR  01 [00  01] ; R[1] = 1
011        RET [01][01] 00  ; return R[1]
012        MOV [01][00] 00  ; R[1] = R[0]
013        MOV [02][00] 00  ; R[2] = R[0]
014     SUBSHR [02][00  01] ; R[2] -= 1
015     LDFUNC [03][00] 00  ; R[3] = F[0]
016       CALL [03][01] 00  ; R[2] = R[3]( R[2]... )
017        MUL [01][02] 00  ; R[1] *= R[2]
018        RET [01][01] 00  ; return R[1]

019      FMSET  00 [00  08] ; MAIN = PC - 0x08 (8) -> PC
020      LDSHR [00][00  04] ; R[0] = 4
021     LDFUNC [01][00  00] ; R[1] = F[0]
022       CALL [01][01] 00  ; R[1] = R[1]( R[0]... )
023        LDK [02][00] 00  ; get global K[0]
024     EUNPAK [02] 00  00  ; R[2] = ENV R[2]
025       CALL [02][01] 00  ; R[2] = R[2]( R[2]... )
026        RET [00] 00  00  ; return (void)

Constants:
           [0]  05 "print"

